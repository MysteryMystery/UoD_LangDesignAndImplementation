
options {
  LOOKAHEAD = 1;
    CHOICE_AMBIGUITY_CHECK = 2;
    OTHER_AMBIGUITY_CHECK = 1;
    STATIC = false;
    DEBUG_PARSER = false;
    DEBUG_LOOKAHEAD = false;
    DEBUG_TOKEN_MANAGER = false;
    ERROR_REPORTING = true;
    JAVA_UNICODE_ESCAPE = false;
    UNICODE_INPUT = false;
    IGNORE_CASE = false;
    USER_TOKEN_MANAGER = false;
    USER_CHAR_STREAM = false;
    BUILD_PARSER = true;
    BUILD_TOKEN_MANAGER = true;
    SANITY_CHECK = true;
    FORCE_LA_CHECK = false;
    MULTI = true;
    VISITOR = true;
    NODE_DEFAULT_VOID = true;
    NODE_EXTENDS = "uk.ac.derby.unimail.jattfield1.foop.lang.BaseASTNode";
    NODE_PACKAGE = "uk.ac.derby.unimail.jattfield1.foop.parser.ast";
    JJTREE_OUTPUT_DIRECTORY = "ast";
}

PARSER_BEGIN(Foop)
package uk.ac.derby.unimail.jattfield1.foop.parser;

public class Foop {
}

PARSER_END(Foop)

/* whitespace */
SKIP : {
  " "
| "\t"
| "\n"
| "\r"
| "\f"
}

/* comments */
SPECIAL_TOKEN : {
    <COMMENT: ">>" (~["\n", "\r"])* "<<" >
}

/* reserved words */
TOKEN [IGNORE_CASE]: {
    < OR: "or" >
   |< AND: "and" >
   |< NOT: "not" >

   |< TRUE: "true">
   |< FALSE: "false">

   | <PRINT: "print">

   | <FOR: "for">
   | <METHOD: "meth">
   | <DOES: "does">
   | <EXPECTS: "expects">
   | <CLASS: "class">
}

/* literals */
TOKEN : {
    <INTEGER_LIT : <DECIMAL_LIT>>
|   <#DECIMAL_LIT: ["0"-"9"] (["0"-"9"])*>
}

/* identifiers */
TOKEN : {
    <CLASS_IDENTIFIER: <UPPERCASE_LETTER> (<LETTER> | <DIGIT> | <UNDERSCORE>)* >
|   <IDENTIFIER: (<UNDERSCORE>)* <LETTER> (<LETTER> | <DIGIT> | <UNDERSCORE>)*>
|   <#LETTER: ["A"-"Z", "a"-"z"]>
|   <#UPPERCASE_LETTER: ["A"-"Z"]>
|   <#DIGIT: ["0"-"9"]>
|   <#UNDERSCORE: "_">
}

/* separators */
TOKEN : {
    <BRACKET_L: "(">
|   <BRACKET_R: ")">
|   <BRACE_L  : "{">
|   <BRACE_R  : "}">
|   <SQU_BRACKET_L: "[">
|   <SQU_BRACKET_R: "]">
|   <SEMICOLON: ";">
|   < COMMA: "," >
|   < DOT: "." >
|   < INCREMENT: "++" >
|   < DECREMENT: "--" >
}

/* operators */
TOKEN :
{
  < ASSIGN: "=" >
| < PEQ: "+=" >
| < MEQ: "-=" >
| < EQ: "is" >
| < GT: "gt" >
| < LT: "lt" >
| < LE: "lte" >
| < GE: "gte" >
| < NE: "is not" >
| < TERN_IF: "?" >
| < TERN_ELSE: ":" >
| < ADD: "+" >
| < SUB: "-" >
| < MUL: "*" >
| < DIV: "/" >
| < MOD: "%" >
}

ASTProgram program() #Program:
{}
{
    statement() /*( statement())* <EOF>*/ {return jjtThis;}
}

void statement() #Statement :
{}
{
    expression() ";"
    | assignmentExpression() ";"
    | output() ";"
    | classDefinition()
}

void classDefinition() #ClassDefinition :
{}
{
    <CLASS> classIdentifier() "{" ( functionDefinition() )* "}"
}

void parameterList() #ParameterList :
{}
{
    [<EXPECTS> <CLASS_IDENTIFIER> identifier() ("," <CLASS_IDENTIFIER> identifier()) *]
}

void functionDefinition() #FunctionDefinition :
{}
{
    <METHOD> identifier() parameterList() <DOES> codeBlock()
}

void codeBlock() #CodeBlock :
{}
{
    <BRACE_L> ( statement() ";" )* <BRACE_R>
}

void output() #Print:
{}
{
    <PRINT> expression()
}

void assignmentExpression():
{}
{
     LOOKAHEAD(2)
            <CLASS_IDENTIFIER> identifier() <ASSIGN> orExpression() #Assignment(2)
            |
            reassignmentExpression()
}

void expression():
{}
{
    orExpression()
}

void reassignmentExpression():
{}
{
    identifier() <ASSIGN> arithmaticExpression() #Reassignment(2)
}

void orExpression() :
{}
{
    andExpression() ( <OR> andExpression() #Or(2) )*
}

void andExpression() :
{}
{
   comparisonExpression() ( <AND> comparisonExpression() #And(2) )*
}

void comparisonExpression():
{}
{
    arithmaticExpression() [
         "=="  arithmaticExpression() #EqualTo(2)
       | "<>" arithmaticExpression() #NotEqualTo(2)
       | ">=" arithmaticExpression() #GreaterThanOrEqualTo(2)
       | "<=" arithmaticExpression() #LessThanOrEqualTo(2)
       | ">"  arithmaticExpression() #GreaterThan(2)
       | "<"  arithmaticExpression() #LessThan(2)
   ]
}

void arithmaticExpression():
{}
{
    multiplicationExpression()
    (
      <ADD> multiplicationExpression() #Add(2)
    | <SUB> multiplicationExpression() #Sub(2)
    )*
}

void multiplicationExpression():
{}
{
    unaryExpression()
    (
         <MUL> unaryExpression() #Multiply(2)
        |<DIV> unaryExpression() #Divide(2)
    )*
}

void unaryExpression():
{}
{
     <NOT> unaryExpression() #Not(1)
    |<ADD> unaryExpression() #UnaryPlus(1)
    |<SUB> unaryExpression() #UnarySub(1)
    | primaryExpression()
}

void primaryExpression():
{}
{
    identifier()
    | literal()
    | collection()
    | "(" expression() ")"
}

void collection() #Collection :
{}
{
    <SQU_BRACKET_L> literal() ( "," literal() )* [","] <SQU_BRACKET_R>
}

void literal():
{}
{
    integer() | bool()
}

void identifier() #Identifier :
{Token t;}
{
    t = <IDENTIFIER> { jjtThis.tokenValue = t.image;}
}

void classIdentifier() #ClassIdentifier :
{Token t;}
{
    t = <CLASS_IDENTIFIER> { jjtThis.tokenValue = t.image;}
}

void integer() #Int :
{Token t;}
{
    t = <INTEGER_LIT> { jjtThis.tokenValue = t.image; }
}

void bool() #Bool :
{Token t;}
{
    t = <TRUE> { jjtThis.tokenValue = t.image; }
    |
    t = <FALSE> { jjtThis.tokenValue = t.image; }
}